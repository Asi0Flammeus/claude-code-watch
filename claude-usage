#!/usr/bin/env python3
"""
Claude Code Usage CLI - Display your Claude Code subscription usage limits.

Fetches usage data from the Anthropic OAuth API and displays it in a clean
terminal interface similar to claude.ai/settings/usage.

Cross-platform support: Linux, macOS, Windows
"""

import json
import os
import platform
import subprocess
import sys
from datetime import datetime, timezone
from pathlib import Path
from urllib.request import Request, urlopen
from urllib.error import HTTPError, URLError

# ═══════════════════════════════════════════════════════════════════════════════
# Configuration
# ═══════════════════════════════════════════════════════════════════════════════

API_URL = "https://api.anthropic.com/api/oauth/usage"
API_BETA_HEADER = "oauth-2025-04-20"

# ANSI color codes (disabled on Windows without colorama or when not a TTY)
class Colors:
    RESET = "\033[0m"
    BOLD = "\033[1m"
    DIM = "\033[2m"

    # Usage level colors
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    RED = "\033[91m"
    CYAN = "\033[96m"
    WHITE = "\033[97m"
    GRAY = "\033[90m"

    # Progress bar
    BAR_FILL = "\033[94m"  # Blue for filled portion
    BAR_EMPTY = "\033[90m"  # Gray for empty portion

# Disable colors if not a TTY or on Windows without proper support
def supports_color():
    if not hasattr(sys.stdout, "isatty") or not sys.stdout.isatty():
        return False
    if platform.system() == "Windows":
        return os.environ.get("TERM") or os.environ.get("WT_SESSION")
    return True

if not supports_color():
    for attr in dir(Colors):
        if not attr.startswith("_"):
            setattr(Colors, attr, "")

# ═══════════════════════════════════════════════════════════════════════════════
# Credential Management
# ═══════════════════════════════════════════════════════════════════════════════

def get_credentials_path() -> Path:
    """Get the credentials file path based on platform."""
    system = platform.system()

    if system == "Windows":
        base = Path(os.environ.get("APPDATA", "~"))
    else:
        base = Path.home()

    return base / ".claude" / ".credentials.json"


def get_macos_keychain_credentials() -> dict | None:
    """Try to get credentials from macOS Keychain."""
    try:
        result = subprocess.run(
            ["security", "find-generic-password", "-s", "Claude Code-credentials", "-w"],
            capture_output=True,
            text=True,
            check=True
        )
        return json.loads(result.stdout.strip())
    except (subprocess.CalledProcessError, json.JSONDecodeError, FileNotFoundError):
        return None


def get_credentials() -> dict:
    """Get Claude Code OAuth credentials."""
    # Try macOS Keychain first on macOS
    if platform.system() == "Darwin":
        creds = get_macos_keychain_credentials()
        if creds:
            return creds

    # Fall back to credentials file
    creds_path = get_credentials_path()

    if not creds_path.exists():
        raise FileNotFoundError(
            f"Credentials not found at {creds_path}\n"
            "Please ensure Claude Code is installed and you've logged in."
        )

    with open(creds_path) as f:
        return json.load(f)


def get_access_token() -> str:
    """Extract the access token from credentials."""
    creds = get_credentials()

    oauth = creds.get("claudeAiOauth", {})
    token = oauth.get("accessToken")

    if not token:
        raise ValueError("No access token found in credentials")

    return token

# ═══════════════════════════════════════════════════════════════════════════════
# API Communication
# ═══════════════════════════════════════════════════════════════════════════════

def fetch_usage() -> dict:
    """Fetch usage data from the Anthropic API."""
    token = get_access_token()

    req = Request(
        API_URL,
        headers={
            "Authorization": f"Bearer {token}",
            "anthropic-beta": API_BETA_HEADER,
            "Content-Type": "application/json",
            "User-Agent": "claude-usage-cli/1.0"
        }
    )

    try:
        with urlopen(req, timeout=10) as response:
            return json.loads(response.read().decode())
    except HTTPError as e:
        if e.code == 401:
            raise RuntimeError(
                "Authentication failed. Your session may have expired.\n"
                "Please re-authenticate with Claude Code."
            )
        raise RuntimeError(f"API error: {e.code} {e.reason}")
    except URLError as e:
        raise RuntimeError(f"Network error: {e.reason}")

# ═══════════════════════════════════════════════════════════════════════════════
# Time Formatting
# ═══════════════════════════════════════════════════════════════════════════════

def parse_reset_time(iso_str: str) -> datetime:
    """Parse ISO 8601 timestamp to datetime."""
    # Handle various ISO formats
    iso_str = iso_str.replace("Z", "+00:00")
    if "." in iso_str:
        # Truncate microseconds if present
        parts = iso_str.split("+")
        if len(parts) == 2:
            iso_str = parts[0].split(".")[0] + "+" + parts[1]

    return datetime.fromisoformat(iso_str)


def format_relative_time(reset_at: str) -> str:
    """Format reset time as relative duration (e.g., '3 hr 33 min')."""
    reset_dt = parse_reset_time(reset_at)
    now = datetime.now(timezone.utc)

    delta = reset_dt - now
    total_seconds = max(0, int(delta.total_seconds()))

    hours = total_seconds // 3600
    minutes = (total_seconds % 3600) // 60

    if hours > 0:
        return f"{hours} hr {minutes} min"
    elif minutes > 0:
        return f"{minutes} min"
    else:
        return "< 1 min"


def format_absolute_time(reset_at: str) -> str:
    """Format reset time as absolute (e.g., 'Tue 9:59 AM')."""
    reset_dt = parse_reset_time(reset_at)
    local_dt = reset_dt.astimezone()

    # Format as "Day HH:MM AM/PM"
    return local_dt.strftime("%a %-I:%M %p").replace(" 0", " ")

# ═══════════════════════════════════════════════════════════════════════════════
# Display Formatting
# ═══════════════════════════════════════════════════════════════════════════════

def make_progress_bar(percentage: float, width: int = 25) -> str:
    """Create a visual progress bar."""
    filled = int(width * percentage / 100)
    empty = width - filled

    # Use block characters for the bar
    bar = f"{Colors.BAR_FILL}{'█' * filled}{Colors.BAR_EMPTY}{'░' * empty}{Colors.RESET}"
    return bar


def get_usage_color(percentage: float) -> str:
    """Get color based on usage percentage."""
    if percentage >= 80:
        return Colors.RED
    elif percentage >= 50:
        return Colors.YELLOW
    return Colors.GREEN


def format_percentage(percentage: float) -> str:
    """Format percentage with color based on usage level."""
    color = get_usage_color(percentage)
    return f"{color}{int(percentage)}% used{Colors.RESET}"


def print_usage_row(label: str, data: dict | None, use_relative_time: bool = False):
    """Print a single usage row with progress bar."""
    if data is None:
        return

    utilization = data.get("utilization", 0)
    resets_at = data.get("resets_at", "")

    # Create progress bar
    bar = make_progress_bar(utilization)
    pct = format_percentage(utilization)

    # Format reset time
    if resets_at:
        if use_relative_time:
            reset_str = f"Resets in {format_relative_time(resets_at)}"
        else:
            reset_str = f"Resets {format_absolute_time(resets_at)}"
    else:
        reset_str = ""

    # Print row
    print(f"{Colors.WHITE}{label:<20}{Colors.RESET} {bar}  {pct}")
    if reset_str:
        print(f"{Colors.DIM}{reset_str}{Colors.RESET}")
    print()


def print_section_header(title: str):
    """Print a section header."""
    print(f"{Colors.BOLD}{Colors.WHITE}{title}{Colors.RESET}")
    print()


def display_usage(data: dict):
    """Display the usage data in a formatted way."""
    print()
    print(f"{Colors.BOLD}{Colors.CYAN}Plan usage limits{Colors.RESET}")
    print()

    # Current session (5-hour window)
    if data.get("five_hour"):
        print_usage_row("Current session", data["five_hour"], use_relative_time=True)

    # Weekly limits section
    print(f"{Colors.BOLD}{Colors.WHITE}Weekly limits{Colors.RESET}")
    print()

    # All models (7-day)
    if data.get("seven_day"):
        print_usage_row("All models", data["seven_day"])

    # Sonnet only
    if data.get("seven_day_sonnet"):
        print_usage_row("Sonnet only", data["seven_day_sonnet"])

    # Opus only (if present)
    if data.get("seven_day_opus"):
        print_usage_row("Opus only", data["seven_day_opus"])

    # Extra usage info (if enabled)
    extra = data.get("extra_usage", {})
    if extra.get("is_enabled"):
        print(f"{Colors.BOLD}{Colors.WHITE}Extra usage{Colors.RESET}")
        print()
        if extra.get("utilization") is not None:
            print_usage_row("Extra credits", {
                "utilization": extra["utilization"],
                "resets_at": None
            })

    # Last updated
    now = datetime.now().strftime("%-I:%M %p").lower()
    print(f"{Colors.DIM}Last updated: just now{Colors.RESET}")
    print()

# ═══════════════════════════════════════════════════════════════════════════════
# JSON Output
# ═══════════════════════════════════════════════════════════════════════════════

def display_json(data: dict):
    """Output raw JSON data."""
    print(json.dumps(data, indent=2))

# ═══════════════════════════════════════════════════════════════════════════════
# Main Entry Point
# ═══════════════════════════════════════════════════════════════════════════════

def main():
    """Main entry point."""
    import argparse

    parser = argparse.ArgumentParser(
        description="Display Claude Code usage limits",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  claude-usage              Show usage in formatted view
  claude-usage --json       Output raw JSON data
  claude-usage --no-color   Disable colored output

Sources:
  API endpoint: https://api.anthropic.com/api/oauth/usage
  Credentials:  ~/.claude/.credentials.json (Linux/Windows)
                macOS Keychain or ~/.claude/.credentials.json (macOS)
"""
    )

    parser.add_argument(
        "--json", "-j",
        action="store_true",
        help="Output raw JSON instead of formatted view"
    )

    parser.add_argument(
        "--no-color",
        action="store_true",
        help="Disable colored output"
    )

    args = parser.parse_args()

    # Disable colors if requested
    if args.no_color:
        for attr in dir(Colors):
            if not attr.startswith("_"):
                setattr(Colors, attr, "")

    try:
        data = fetch_usage()

        if args.json:
            display_json(data)
        else:
            display_usage(data)

    except FileNotFoundError as e:
        print(f"{Colors.RED}Error: {e}{Colors.RESET}", file=sys.stderr)
        sys.exit(1)
    except (RuntimeError, ValueError) as e:
        print(f"{Colors.RED}Error: {e}{Colors.RESET}", file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        print()
        sys.exit(130)


if __name__ == "__main__":
    main()
